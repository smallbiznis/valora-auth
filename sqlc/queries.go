// Code generated by sqlc-like tooling. DO NOT EDIT.
package sqlc

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

// DBTX matches pgxpool.Pool and pgx.Conn interfaces.
type DBTX interface {
	Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
	Query(context.Context, string, ...interface{}) (pgx.Rows, error)
	QueryRow(context.Context, string, ...interface{}) pgx.Row
}

// Queries wraps prepared statements used by repositories.
type Queries struct {
	db DBTX
}

// New instantiates Queries.
func New(db DBTX) *Queries {
	return &Queries{db: db}
}

// Domain rows.
type GetDomainByHostRow struct {
	ID       int64
	Host     string
	TenantID int64
}

const getDomainByHostSQL = `SELECT id, host, tenant_id FROM domains WHERE host = $1 LIMIT 1`

func (q *Queries) GetDomainByHost(ctx context.Context, host string) (GetDomainByHostRow, error) {
	row := q.db.QueryRow(ctx, getDomainByHostSQL, host)
	var res GetDomainByHostRow
	err := row.Scan(&res.ID, &res.Host, &res.TenantID)
	return res, err
}

const getPrimaryDomainSQL = `SELECT id, host, tenant_id FROM domains WHERE tenant_id = $1 ORDER BY is_primary DESC, id ASC LIMIT 1`

func (q *Queries) GetPrimaryDomain(ctx context.Context, tenantID int64) (GetDomainByHostRow, error) {
	row := q.db.QueryRow(ctx, getPrimaryDomainSQL, tenantID)
	var res GetDomainByHostRow
	err := row.Scan(&res.ID, &res.Host, &res.TenantID)
	return res, err
}

// Tenant row.
type GetTenantRow struct {
	ID          int64
	Type        string
	Name        string
	Code        string
	Slug        string
	CountryCode string
	Timezone    string
	IsDefault   bool
	Status      string
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

const getTenantSQL = `SELECT id, type, name, code, slug, country_code, timezone, is_default, status, created_at, updated_at FROM tenants WHERE id = $1 LIMIT 1`

func (q *Queries) GetTenant(ctx context.Context, tenantID int64) (GetTenantRow, error) {
	row := q.db.QueryRow(ctx, getTenantSQL, tenantID)
	var res GetTenantRow
	err := row.Scan(
		&res.ID,
		&res.Type,
		&res.Name,
		&res.Code,
		&res.Slug,
		&res.CountryCode,
		&res.Timezone,
		&res.IsDefault,
		&res.Status,
		&res.CreatedAt,
		&res.UpdatedAt,
	)
	return res, err
}

const getTenantBySlugSQL = `SELECT id, type, name, code, slug, country_code, timezone, is_default, status, created_at, updated_at FROM tenants WHERE slug = $1 LIMIT 1`

func (q *Queries) GetTenantBySlug(ctx context.Context, slug string) (GetTenantRow, error) {
	row := q.db.QueryRow(ctx, getTenantBySlugSQL, slug)
	var res GetTenantRow
	err := row.Scan(
		&res.ID,
		&res.Type,
		&res.Name,
		&res.Code,
		&res.Slug,
		&res.CountryCode,
		&res.Timezone,
		&res.IsDefault,
		&res.Status,
		&res.CreatedAt,
		&res.UpdatedAt,
	)
	return res, err
}

// Branding row.
type GetBrandingRow struct {
	TenantID     int64
	LogoURL      string
	PrimaryColor string
}

const getBrandingSQL = `SELECT tenant_id, COALESCE(logo_url, '') AS logo_url, COALESCE(primary_color, '') AS primary_color FROM brandings WHERE tenant_id = $1 LIMIT 1`

func (q *Queries) GetBranding(ctx context.Context, tenantID int64) (GetBrandingRow, error) {
	row := q.db.QueryRow(ctx, getBrandingSQL, tenantID)
	var res GetBrandingRow
	err := row.Scan(&res.TenantID, &res.LogoURL, &res.PrimaryColor)
	return res, err
}

// Auth provider rows.
type ListAuthProvidersRow struct {
	ID               int64
	TenantID         int64
	ProviderType     string
	ProviderConfigID sql.NullInt64
	IsActive         bool
	CreatedAt        time.Time
	UpdatedAt        time.Time
}

const listAuthProvidersSQL = `SELECT id, tenant_id, provider_type, provider_config_id, is_active, created_at, updated_at FROM tenant_auth_providers WHERE tenant_id = $1`

func (q *Queries) ListAuthProviders(ctx context.Context, tenantID int64) ([]ListAuthProvidersRow, error) {
	rows, err := q.db.Query(ctx, listAuthProvidersSQL, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var res []ListAuthProvidersRow
	for rows.Next() {
		var r ListAuthProvidersRow
		if err := rows.Scan(&r.ID, &r.TenantID, &r.ProviderType, &r.ProviderConfigID, &r.IsActive, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, err
		}
		res = append(res, r)
	}
	return res, rows.Err()
}

// Password config row.
type GetPasswordConfigRow struct {
	TenantID               int64
	MinLength              int32
	RequireUppercase       bool
	RequireNumber          bool
	RequireSymbol          bool
	AllowSignup            bool
	AllowPasswordReset     bool
	LockoutAttempts        int32
	LockoutDurationSeconds int32
	CreatedAt              time.Time
	UpdatedAt              time.Time
}

const getPasswordConfigSQL = `SELECT tenant_id, min_length, require_uppercase, require_number, require_symbol, allow_signup, allow_password_reset, lockout_attempts, lockout_duration_seconds, created_at, updated_at FROM password_configs WHERE tenant_id = $1 LIMIT 1`

func (q *Queries) GetPasswordConfig(ctx context.Context, tenantID int64) (GetPasswordConfigRow, error) {
	row := q.db.QueryRow(ctx, getPasswordConfigSQL, tenantID)
	var res GetPasswordConfigRow
	err := row.Scan(
		&res.TenantID,
		&res.MinLength,
		&res.RequireUppercase,
		&res.RequireNumber,
		&res.RequireSymbol,
		&res.AllowSignup,
		&res.AllowPasswordReset,
		&res.LockoutAttempts,
		&res.LockoutDurationSeconds,
		&res.CreatedAt,
		&res.UpdatedAt,
	)
	return res, err
}

// OTP config row.
type GetOTPConfigRow struct {
	TenantID      int64
	Channel       string
	Provider      string
	APIKey        sql.NullString
	Sender        sql.NullString
	Template      sql.NullString
	ExpirySeconds int32
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

const getOTPConfigSQL = `SELECT tenant_id, channel, provider, api_key, sender, template, expiry_seconds, created_at, updated_at FROM otp_configs WHERE tenant_id = $1 LIMIT 1`

func (q *Queries) GetOTPConfig(ctx context.Context, tenantID int64) (GetOTPConfigRow, error) {
	row := q.db.QueryRow(ctx, getOTPConfigSQL, tenantID)
	var res GetOTPConfigRow
	err := row.Scan(
		&res.TenantID,
		&res.Channel,
		&res.Provider,
		&res.APIKey,
		&res.Sender,
		&res.Template,
		&res.ExpirySeconds,
		&res.CreatedAt,
		&res.UpdatedAt,
	)
	return res, err
}

// OAuth IDP config rows.
type ListOAuthIDPConfigsRow struct {
	TenantID         int64
	Provider         string
	ClientID         string
	ClientSecret     string
	IssuerURL        string
	AuthorizationURL string
	TokenURL         string
	UserinfoURL      string
	JWKSURL          string
	Scopes           []string
	Extra            []byte
	CreatedAt        time.Time
	UpdatedAt        time.Time
}

const listOAuthIDPConfigsSQL = `SELECT tenant_id, provider, client_id, client_secret, issuer_url, authorization_url, token_url, userinfo_url, jwks_url, scopes, extra, created_at, updated_at FROM oauth_idp_configs WHERE tenant_id = $1`

func (q *Queries) ListOAuthIDPConfigs(ctx context.Context, tenantID int64) ([]ListOAuthIDPConfigsRow, error) {
	rows, err := q.db.Query(ctx, listOAuthIDPConfigsSQL, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var res []ListOAuthIDPConfigsRow

	for rows.Next() {
		var r ListOAuthIDPConfigsRow
		var scopes []string // FIX: gunakan slice langsung

		if err := rows.Scan(
			&r.TenantID,
			&r.Provider,
			&r.ClientID,
			&r.ClientSecret,
			&r.IssuerURL,
			&r.AuthorizationURL,
			&r.TokenURL,
			&r.UserinfoURL,
			&r.JWKSURL,
			&scopes, // FIX: scan ke []string
			&r.Extra,
			&r.CreatedAt,
			&r.UpdatedAt,
		); err != nil {
			return nil, fmt.Errorf("scan idp: %w", err)
		}

		r.Scopes = scopes

		res = append(res, r)
	}

	return res, rows.Err()
}

// User row.
type GetUserByEmailRow struct {
	ID            int64
	TenantID      int64
	Email         string
	EmailVerified bool
	PasswordHash  string
	Name          string
	Phone         string
	PhoneVerified bool
	AvatarURL     sql.NullString
	Status        string
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

const getUserByEmailSQL = `SELECT id, tenant_id, email, email_verified, password_hash, name, phone, phone_verified, avatar_url, status, created_at, updated_at FROM users WHERE tenant_id = $1 AND email = $2 LIMIT 1`

func (q *Queries) GetUserByEmail(ctx context.Context, tenantID int64, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmailSQL, tenantID, email)
	var res GetUserByEmailRow
	err := row.Scan(
		&res.ID,
		&res.TenantID,
		&res.Email,
		&res.EmailVerified,
		&res.PasswordHash,
		&res.Name,
		&res.Phone,
		&res.PhoneVerified,
		&res.AvatarURL,
		&res.Status,
		&res.CreatedAt,
		&res.UpdatedAt,
	)
	return res, err
}

const getUserByIDSQL = `SELECT id, tenant_id, email, email_verified, password_hash, name, phone, phone_verified, avatar_url, status, created_at, updated_at FROM users WHERE tenant_id = $1 AND id = $2 LIMIT 1`

func (q *Queries) GetUserByID(ctx context.Context, tenantID, userID int64) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByIDSQL, tenantID, userID)
	var res GetUserByEmailRow
	err := row.Scan(
		&res.ID,
		&res.TenantID,
		&res.Email,
		&res.EmailVerified,
		&res.PasswordHash,
		&res.Name,
		&res.Phone,
		&res.PhoneVerified,
		&res.AvatarURL,
		&res.Status,
		&res.CreatedAt,
		&res.UpdatedAt,
	)
	return res, err
}

// OAuth token rows.
type InsertOAuthTokenRow struct {
	ID           int64
	TenantID     int64
	ClientID     string
	UserID       int64
	AccessToken  string
	RefreshToken sql.NullString
	Scopes       []string
	ExpiresAt    time.Time
	Revoked      bool
	CreatedAt    time.Time
}

const insertOAuthTokenSQL = `INSERT INTO oauth_tokens (id, tenant_id, client_id, user_id, access_token, refresh_token, scopes, expires_at) VALUES ($1,$2,$3,$4,$5,$6,$7,$8) RETURNING id, tenant_id, client_id, user_id, access_token, refresh_token, scopes, expires_at, revoked, created_at`

func (q *Queries) InsertOAuthToken(ctx context.Context, ID, tenantID int64, clientID string, userID int64, accessToken string, refreshToken sql.NullString, scopes []string, expiresAt time.Time) (InsertOAuthTokenRow, error) {
	row := q.db.QueryRow(ctx, insertOAuthTokenSQL, ID, tenantID, clientID, userID, accessToken, refreshToken, scopes, expiresAt)
	var res InsertOAuthTokenRow
	err := row.Scan(&res.ID, &res.TenantID, &res.ClientID, &res.UserID, &res.AccessToken, &res.RefreshToken, &res.Scopes, &res.ExpiresAt, &res.Revoked, &res.CreatedAt)
	return res, err
}

const getOAuthTokenByRefreshSQL = `SELECT id, tenant_id, client_id, user_id, access_token, refresh_token, scopes, expires_at, revoked, created_at FROM oauth_tokens WHERE tenant_id = $1 AND refresh_token = $2 LIMIT 1`

func (q *Queries) GetOAuthTokenByRefresh(ctx context.Context, tenantID int64, refreshToken string) (InsertOAuthTokenRow, error) {
	row := q.db.QueryRow(ctx, getOAuthTokenByRefreshSQL, tenantID, refreshToken)
	var res InsertOAuthTokenRow
	err := row.Scan(&res.ID, &res.TenantID, &res.ClientID, &res.UserID, &res.AccessToken, &res.RefreshToken, &res.Scopes, &res.ExpiresAt, &res.Revoked, &res.CreatedAt)
	return res, err
}

const getOAuthTokenByRefreshValueSQL = `SELECT id, tenant_id, client_id, user_id, access_token, refresh_token, scopes, expires_at, revoked, created_at FROM oauth_tokens WHERE refresh_token = $1 LIMIT 1`

func (q *Queries) GetOAuthTokenByRefreshValue(ctx context.Context, refreshToken string) (InsertOAuthTokenRow, error) {
	row := q.db.QueryRow(ctx, getOAuthTokenByRefreshValueSQL, refreshToken)
	var res InsertOAuthTokenRow
	err := row.Scan(&res.ID, &res.TenantID, &res.ClientID, &res.UserID, &res.AccessToken, &res.RefreshToken, &res.Scopes, &res.ExpiresAt, &res.Revoked, &res.CreatedAt)
	return res, err
}

const getOAuthTokenByAccessSQL = `SELECT id, tenant_id, client_id, user_id, access_token, refresh_token, scopes, expires_at, revoked, created_at FROM oauth_tokens WHERE access_token = $1 LIMIT 1`

func (q *Queries) GetOAuthTokenByAccess(ctx context.Context, accessToken string) (InsertOAuthTokenRow, error) {
	row := q.db.QueryRow(ctx, getOAuthTokenByAccessSQL, accessToken)
	var res InsertOAuthTokenRow
	err := row.Scan(&res.ID, &res.TenantID, &res.ClientID, &res.UserID, &res.AccessToken, &res.RefreshToken, &res.Scopes, &res.ExpiresAt, &res.Revoked, &res.CreatedAt)
	return res, err
}

const rotateRefreshTokenSQL = `UPDATE oauth_tokens SET refresh_token = $2, expires_at = $3 WHERE id = $1`

func (q *Queries) RotateRefreshToken(ctx context.Context, id int64, refreshToken string, expiresAt time.Time) error {
	_, err := q.db.Exec(ctx, rotateRefreshTokenSQL, id, refreshToken, expiresAt)
	return err
}

const revokeOAuthTokenSQL = `UPDATE oauth_tokens SET revoked = true WHERE id = $1`

func (q *Queries) RevokeOAuthToken(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, revokeOAuthTokenSQL, id)
	return err
}

// OAuth code rows.
type GetOAuthCodeRow struct {
	ID                  int64
	TenantID            int64
	ClientID            string
	UserID              int64
	Code                string
	RedirectURI         string
	CodeChallenge       sql.NullString
	CodeChallengeMethod sql.NullString
	ExpiresAt           time.Time
	Revoked             bool
	CreatedAt           time.Time
}

const insertOAuthCodeSQL = `INSERT INTO oauth_codes (id, tenant_id, client_id, user_id, code, redirect_uri, code_challenge, code_challenge_method, expires_at) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9)`

func (q *Queries) InsertOAuthCode(ctx context.Context, id, tenantID int64, clientID string, userID int64, code, redirectURI string, codeChallenge sql.NullString, codeChallengeMethod sql.NullString, expiresAt time.Time) error {
	_, err := q.db.Exec(ctx, insertOAuthCodeSQL, id, tenantID, clientID, userID, code, redirectURI, codeChallenge, codeChallengeMethod, expiresAt)
	return err
}

const getOAuthCodeSQL = `SELECT id, tenant_id, client_id, user_id, code, redirect_uri, code_challenge, code_challenge_method, expires_at, revoked, created_at FROM oauth_codes WHERE tenant_id = $1 AND code = $2 LIMIT 1`

func (q *Queries) GetOAuthCode(ctx context.Context, tenantID int64, code string) (GetOAuthCodeRow, error) {
	row := q.db.QueryRow(ctx, getOAuthCodeSQL, tenantID, code)
	var res GetOAuthCodeRow
	err := row.Scan(
		&res.ID,
		&res.TenantID,
		&res.ClientID,
		&res.UserID,
		&res.Code,
		&res.RedirectURI,
		&res.CodeChallenge,
		&res.CodeChallengeMethod,
		&res.ExpiresAt,
		&res.Revoked,
		&res.CreatedAt,
	)
	return res, err
}

const revokeOAuthCodeSQL = `UPDATE oauth_codes SET revoked = true WHERE code = $1`

func (q *Queries) RevokeOAuthCode(ctx context.Context, code string) error {
	_, err := q.db.Exec(ctx, revokeOAuthCodeSQL, code)
	return err
}

// OAuth keys.
type GetActiveOAuthKeyRow struct {
	ID        int64
	TenantID  int64
	KID       string
	Secret    []byte
	Algorithm string
	IsActive  bool
	CreatedAt time.Time
	RotatedAt sql.NullTime
}

const getActiveOAuthKeySQL = `SELECT id, tenant_id, kid, secret, algorithm, is_active, created_at, rotated_at FROM oauth_keys WHERE tenant_id = $1 AND is_active = true ORDER BY created_at DESC LIMIT 1`

func (q *Queries) GetActiveOAuthKey(ctx context.Context, tenantID int64) (GetActiveOAuthKeyRow, error) {
	row := q.db.QueryRow(ctx, getActiveOAuthKeySQL, tenantID)
	var res GetActiveOAuthKeyRow
	err := row.Scan(&res.ID, &res.TenantID, &res.KID, &res.Secret, &res.Algorithm, &res.IsActive, &res.CreatedAt, &res.RotatedAt)
	if errors.Is(err, pgx.ErrNoRows) {
		return res, err
	}
	return res, err
}

const insertOAuthKeySQL = `INSERT INTO oauth_keys (tenant_id, kid, secret, algorithm, is_active) VALUES ($1,$2,$3,$4,true) RETURNING id, tenant_id, kid, secret, algorithm, is_active, created_at, rotated_at`

func (q *Queries) InsertOAuthKey(ctx context.Context, tenantID int64, kid string, secret []byte, algorithm string) (GetActiveOAuthKeyRow, error) {
	row := q.db.QueryRow(ctx, insertOAuthKeySQL, tenantID, kid, secret, algorithm)
	var res GetActiveOAuthKeyRow
	err := row.Scan(&res.ID, &res.TenantID, &res.KID, &res.Secret, &res.Algorithm, &res.IsActive, &res.CreatedAt, &res.RotatedAt)
	return res, err
}
